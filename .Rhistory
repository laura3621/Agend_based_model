?mtext
# Assuming max_means and max_sd are already defined
max_means <- colMeans(max_values_df)
max_sd <- apply(max_values_df, 1, sd)
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay Cost
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
axis(4, col = "blue", col.axis = "blue")
mtext("Cost in CHF", side = 4, line = 3, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
# Optional: Highlight intersection points if necessary
# Identify where the curves are closest
intersect_idx <- which.min(abs(max_means - cost))
points(classroom[intersect_idx], max_means[intersect_idx], col = "red", pch = 19)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
#axis(4, col = "blue", col.axis = "blue")
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
#axis(4, col = "blue", col.axis = "blue")
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
axis(4) #col = "blue", col.axis = "blue"
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
### 4. Randomly assign seats for attending students
#### a. get attendance status for each students
#### b. assign seats to attending students
### 5. Calculate probability of infection for each students
#### a. get students(who are not immune)who got infected outside of class
#### b. calculate probability of infection for each students
### 6. From the probabilities, determine which student get infected
### 7. Loop multiple times and track infection status each round
#### a. update infection status for each round in meta sheet (?)
#### b. update "health" dataframe
rm(list=ls())
setwd("~/UZH/Agent-based modelling in R/Agend_based_model")
setwd("~/Documents/GitHub/Agend_based_model") #Miriam
#setwd("~/UZH/Agent-based modelling in R/Agend_based_model")
setwd("C:/Users/Laura Andres/Documents/GitHub/Agend_based_model/")
function (..., list = character(), package = NULL, lib.loc = NULL,
verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE)
{
fileExt <- function(x) {
db <- grepl("\\.[^.]+\\.(gz|bz2|xz)$", x)
ans <- sub(".*\\.", "", x)
ans[db] <- sub(".*\\.([^.]+\\.)(gz|bz2|xz)$", "\\1\\2",
x[db])
ans
}
my_read_table <- function(...) {
lcc <- Sys.getlocale("LC_COLLATE")
on.exit(Sys.setlocale("LC_COLLATE", lcc))
Sys.setlocale("LC_COLLATE", "C")
read.table(...)
}
stopifnot(is.character(list))
names <- c(as.character(substitute(list(...))[-1L]), list)
if (!is.null(package)) {
if (!is.character(package))
stop("'package' must be a character vector or NULL")
}
paths <- find.package(package, lib.loc, verbose = verbose)
if (is.null(lib.loc))
paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),
paths)
paths <- unique(normalizePath(paths[file.exists(paths)]))
paths <- paths[dir.exists(file.path(paths, "data"))]
dataExts <- tools:::.make_file_exts("data")
if (length(names) == 0L) {
db <- matrix(character(), nrow = 0L, ncol = 4L)
for (path in paths) {
entries <- NULL
packageName <- if (file_test("-f", file.path(path,
"DESCRIPTION")))
basename(path)
else "."
if (file_test("-f", INDEX <- file.path(path, "Meta",
"data.rds"))) {
entries <- readRDS(INDEX)
}
else {
dataDir <- file.path(path, "data")
entries <- tools::list_files_with_type(dataDir,
"data")
if (length(entries)) {
entries <- unique(tools::file_path_sans_ext(basename(entries)))
entries <- cbind(entries, "")
}
}
if (NROW(entries)) {
if (is.matrix(entries) && ncol(entries) == 2L)
db <- rbind(db, cbind(packageName, dirname(path),
entries))
else warning(gettextf("data index for package %s is invalid and will be ignored",
sQuote(packageName)), domain = NA, call. = FALSE)
}
}
colnames(db) <- c("Package", "LibPath", "Item", "Title")
footer <- if (missing(package))
paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")),
"\n", "to list the data sets in all *available* packages.")
else NULL
y <- list(title = "Data sets", header = NULL, results = db,
footer = footer)
class(y) <- "packageIQR"
return(y)
}
paths <- file.path(paths, "data")
for (name in names) {
found <- FALSE
for (p in paths) {
tmp_env <- if (overwrite)
envir
else new.env()
if (file_test("-f", file.path(p, "Rdata.rds"))) {
rds <- readRDS(file.path(p, "Rdata.rds"))
if (name %in% names(rds)) {
found <- TRUE
if (verbose)
message(sprintf("name=%s:\t found in Rdata.rds",
name), domain = NA)
thispkg <- sub(".*/([^/]*)/data$", "\\1",
p)
thispkg <- sub("_.*$", "", thispkg)
thispkg <- paste0("package:", thispkg)
objs <- rds[[name]]
lazyLoad(file.path(p, "Rdata"), envir = tmp_env,
filter = function(x) x %in% objs)
break
}
else if (verbose)
message(sprintf("name=%s:\t NOT found in names() of Rdata.rds, i.e.,\n\t%s\n",
name, paste(names(rds), collapse = ",")),
domain = NA)
}
if (file_test("-f", file.path(p, "Rdata.zip"))) {
warning("zipped data found for package ", sQuote(basename(dirname(p))),
".\nThat is defunct, so please re-install the package.",
domain = NA)
if (file_test("-f", fp <- file.path(p, "filelist")))
files <- file.path(p, scan(fp, what = "",
quiet = TRUE))
else {
warning(gettextf("file 'filelist' is missing for directory %s",
sQuote(p)), domain = NA)
next
}
}
else {
files <- list.files(p, full.names = TRUE)
}
files <- files[grep(name, files, fixed = TRUE)]
if (length(files) > 1L) {
o <- match(fileExt(files), dataExts, nomatch = 100L)
paths0 <- dirname(files)
paths0 <- factor(paths0, levels = unique(paths0))
files <- files[order(paths0, o)]
}
if (length(files)) {
for (file in files) {
if (verbose)
message("name=", name, ":\t file= ...",
.Platform$file.sep, basename(file), "::\t",
appendLF = FALSE, domain = NA)
ext <- fileExt(file)
if (basename(file) != paste0(name, ".", ext))
found <- FALSE
else {
found <- TRUE
zfile <- file
zipname <- file.path(dirname(file), "Rdata.zip")
if (file.exists(zipname)) {
Rdatadir <- tempfile("Rdata")
dir.create(Rdatadir, showWarnings = FALSE)
topic <- basename(file)
rc <- .External(C_unzip, zipname, topic,
Rdatadir, FALSE, TRUE, FALSE, FALSE)
if (rc == 0L)
zfile <- file.path(Rdatadir, topic)
}
if (zfile != file)
on.exit(unlink(zfile))
switch(ext, R = , r = {
library("utils")
sys.source(zfile, chdir = TRUE, envir = tmp_env)
}, RData = , rdata = , rda = load(zfile,
envir = tmp_env), TXT = , txt = , tab = ,
tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,
txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,
header = TRUE, as.is = FALSE), envir = tmp_env),
CSV = , csv = , csv.gz = , csv.bz2 = ,
csv.xz = assign(name, my_read_table(zfile,
header = TRUE, sep = ";", as.is = FALSE),
envir = tmp_env), found <- FALSE)
}
if (found)
break
}
if (verbose)
message(if (!found)
"*NOT* ", "found", domain = NA)
}
if (found)
break
}
if (!found) {
warning(gettextf("data set %s not found", sQuote(name)),
domain = NA)
}
else if (!overwrite) {
for (o in ls(envir = tmp_env, all.names = TRUE)) {
if (exists(o, envir = envir, inherits = FALSE))
warning(gettextf("an object named %s already exists and will not be overwritten",
sQuote(o)))
else assign(o, get(o, envir = tmp_env, inherits = FALSE),
envir = envir)
}
rm(tmp_env)
}
}
invisible(names)
}
rm(list=ls())
source("get_transmissable_distance.R")
source("probability_to_binary.R")
#### 1. Determine Parameters
beta <- 0.3
students <- 100
transmission_dist <- 1.5 #in number of seats between students
random_absence <- 0.05
lectures_per_week <- 1 #per week
weeks <- 13 #fix in the end to 18 weeks -> one semester + study phase
transmission_dist <- 2 #get_transmissable_distance(beta, threshold = 0.05) #dist 1 = one seat(60cm)
initial_prob <- 0.05
rounds <- lectures_per_week*weeks
# create new metasheet
new_meta=function(){
meta=data.frame(
infected = rep(NA, rounds),
immunity = NA,
recovering = NA,
sick_but_going = NA,
mean_stored = NA
)
return(meta)
}
#### 2. Make a dataframe that contains student information
new_health=function(){
health <- data.frame(
ID = 1:students,
infected_pre = 0,
absence = 0,
location = 0,
row=0,
col=0,
missed_rounds = 0,
past_affections = 0,
p = 0, #probability of getting infected
infected_post = 0, #infection status after this round
immunity = 0,
sick_but_going = 0)
return(health)
}
one_round=function(nth_round, beta, students, transmission_dist,random_absence,lectures_per_week,weeks,initial_prob,rounds, meta, seats, health){
#### 4. Randomly assign seats for attending students
# 4a. get absent students
## making voluntary decision not to come..
health$absence <- sample(0:1, students, replace = TRUE, prob = c(1-random_absence, random_absence))
## cannot come anyway due to infection
health$absence[which(health$missed_rounds>=1)] <- 1
# 4b. assign seats to attending students
attending_students <- which(health$absence==0)
health$location[attending_students]=sample(1:nrow(seats), length(attending_students), replace = FALSE)
health$row[attending_students]=seats$rows[health$location]
health$col[attending_students]=seats$cols[health$location]
### 5. Calculate probability of infection for each students
# 5a. get students(who are not immune)who got infected outside of class
possible_hosts=which(health$immunity == 0)
health$infected_pre[possible_hosts]=sample(0:1, length(possible_hosts), replace = TRUE, prob=c(1-initial_prob,initial_prob))
health$immunity[which(health$infected_pre ==1)]=1
# 5b. calculate probability of infection for each students
#distance matrix for all seats
distances <- as.matrix(dist(cbind(health$row,health$col)))
distances <- distances[,which(health$infected_pre==1), drop=FALSE]
#get number of exposures for each students
health$exposures<-rowSums(distances<=transmission_dist)
#get probability of infection by number of exposures
health$p=1-(1-beta)^health$exposures
### 6. From the probabilities, determine which student get infected
for(i in 1:nrow(health)){
if(health$immunity[i] == 1){
health$infected_post[i] = 0
} else{
health$infected_post[i]<-probability_to_binary(health$p[i])
}
}
### 7. Loop multiple times and track infection status each round
# 7a. update infection status for each round in meta sheet
meta$infected[nth_round] <- sum(health$infected_post)
meta$immunity[nth_round] <- sum(health$immunity)
meta$recovering[nth_round] <- length(which(health$missed_rounds>=1))
meta$sick_but_going[nth_round] <- length(which(health$sick_but_going>=1))
#7b. update "health" dataframe
quarantine <- which(health$sick_but_going==lectures_per_week)
# print(quarantine)
back_to_school <- which(health$missed_rounds==lectures_per_week)
# print(back_to_school)
#clear infection status of students in quarantine
health$sick_but_going[quarantine] <- 0
health$infected_post[quarantine] <- 0
#count missed rounds of students in quarantine
health$missed_rounds[quarantine] <- health$missed_rounds[quarantine]+1
#get students back to class + immunity
health$missed_rounds[back_to_school] <- 0
health$immunity[back_to_school] <- 1
health$infected_pre[back_to_school] <- 0
#add counts for students who got sick and still goes to school
health$sick_but_going[which(health$infected_post==1)] <-health$sick_but_going[which(health$infected_post==1)] +1
#transfer infected_post as infect_pre of next round
health$infected_pre <- health$infected_post
#clear other columns
health$attendance <- 0
health$location <- 0
health$p <- 0
health$infected_post <- 0
# mean for the defined weeks (now 13 weeks)
if(nth_round <= weeks) {
meta$infected_stored[nth_round] <- meta$infected[nth_round]
} else {
meta$infected_stored[nth_round] <- 0
}
return(list(health = health, meta = meta))
}
n=100 #number of simulations
nrows <- ncols <- c(10:20)
# make empty dataframe that will store the peak of infection
max_values_df= data.frame(matrix(NA, nrow = n, ncol = length(nrows)))
colnames(max_values_df)=paste("size", 1:length(nrows)+9, sep="_")
for(j in nrows) {
seats <- expand.grid(rows=1:j, cols=1:j)
seats$ID <- 1:nrow(seats)
# make a dataframe to track result in each simulation
column_names <- paste("trial", 1:n, sep= "_")
infected_df <- data.frame(matrix(NA, nrow = rounds, ncol = n))
colnames(infected_df) <- column_names
# repeat simulation 100 times for each conditions (for statistical validation)
## empty vector to update means of infected students
mean_simulation=rep(NA, n)
## simulate!
for(trial in 1:n){
health=new_health()
meta=new_meta()
for(nth_round in 1:rounds) {
results <- one_round(nth_round, beta, students, transmission_dist,random_absence,lectures_per_week,weeks,initial_prob,rounds, meta, seats, health)
health <- results$health
meta <- results$meta
}
## update mean of infected students
meta[is.na(meta)]=0
mean_one_simulation <- sum(meta$infected_stored)/weeks
mean_simulation[trial]=mean_one_simulation
## update the result - infected_df - dataframe
infected_df[trial]=meta$infected
}
## get descriptive statistics from infected_df
### set NA as 0
infected_df[is.na(infected_df)]=0
### get means and sd and max and min
mean_weeks=rowMeans(infected_df)
sd_weeks=apply(infected_df,1,sd)
sd_simulation=apply(infected_df,2,sd)
max_simulation=apply(infected_df,2,max)
min_simulation=apply(infected_df,2,min)
### update max_values_df
max_values_df[j-9]=max_simulation
}
max_means=colMeans(max_values_df)
max_sd=apply(max_values_df, 1, sd)
# change the column names of max_values
colnames(max_values_df) <- c("10x10", "11x11", "12x12", "13x13", "14x14", "15x15", "16x16", "17x17", "18x18", "19x19", "20x20")
boxplot(max_values_df,
main = "Boxplots for each Condition",
xlab = "Classroom Size",
ylab = "Highest nr. of infected Individuals per Condition",
col = "lightpink")
# One plot for both curves
# max_means and max_sd
max_means <- colMeans(max_values_df)
max_sd <- apply(max_values_df, 1, sd)
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
axis(4) #col = "blue", col.axis = "blue"
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
##############
##############
##############
##############
# One plot for both curves
# max_means and max_sd
max_means <- colMeans(max_values_df)
max_sd <- apply(max_values_df, 1, sd)
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
axis(4) #col = "blue", col.axis = "blue"
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
axis("Cost in CHF",4) #col = "blue", col.axis = "blue"
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
# Define cost based on classroom size using a logarithmic scale
classroom <- 10:20
starting_value <- 10000
# Use a logarithmic function to define the cost
cost <- starting_value * log(classroom)
# Plot Mean Infected
plot(x = classroom, y = max_means, type = 'l', col = 'violet', lwd = 2, ylab = 'Mean Infected', xlab = 'Classroom Size', xaxt = 'n')
axis(1, at = classroom)
# Overlay log(Cost)
par(new = TRUE)
plot(x = classroom, y = cost, type = 'l', col = 'blue', lwd = 2, axes = FALSE, xlab = '', ylab = '')
axis(4)
mtext("Cost in CHF", side = 4, line = 2, col = "blue")
# Add legends
legend("topright", legend = c("Mean Infected", "Cost in CHF"), col = c("violet", "blue"), lty = 1, lwd = 2)
# Add a title
title(main = "Plot of Mean Infected and Cost in CHF")
room <- 14*14
room <- 14*14
capcity <- room/100
print(capcity)
print(room)
